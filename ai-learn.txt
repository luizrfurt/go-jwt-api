 
============================================= 
ARQUIVO: C:\go-projects\go-jwt-api\main.go 
============================================= 
 
// main.go
package main

import (
	"go-jwt-api/config"
	"go-jwt-api/db"
	"go-jwt-api/routes"
	"go-jwt-api/services"
	"go-jwt-api/utils"
	"net/http"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
)

func main() {
	config.LoadConfig()
	db.InitDBConfig()
	services.InitAuthConfig()

	r := gin.Default()

	portWeb := config.AppConfig.PortWeb

	r.Use(cors.New(cors.Config{
		AllowOrigins:     []string{"http://localhost:" + portWeb},
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE"},
		AllowHeaders:     []string{"Authorization", "Content-Type"},
		ExposeHeaders:    []string{"Authorization"},
		AllowCredentials: true,
	}))

	r.GET("/", func(c *gin.Context) {
		utils.SendJSON(c, http.StatusOK, gin.H{"message": "API is running"}, []string{})
	})

	r.GET("/docs", func(c *gin.Context) {
		c.File("./tools/docs.html")
	})

	routes.SetupRoutes(r)

	r.Run(":" + config.AppConfig.Port)
}
 
 
 
============================================= 
ARQUIVO: C:\go-projects\go-jwt-api\config\config.go 
============================================= 
 
// config/config.go
package config

import (
	"log"
	"os"

	"github.com/joho/godotenv"
	"github.com/spf13/cast"
)

type Config struct {
	Port         string
	PortWeb      string
	Environment  string
	DBHost       string
	DBPort       string
	DBUser       string
	DBPassword   string
	DBName       string
	JwtKey       string
	MailHost     string
	MailPort     int
	MailUsername string
	MailPassword string
}

var AppConfig *Config

func LoadConfig() {
	err := godotenv.Load()
	if err != nil {
		log.Println("No .env file found or failed to load it")
	}

	AppConfig = &Config{
		Port:         getEnv("PORT", "8080"),
		PortWeb:      getEnv("PORT_WEB", "8080"),
		Environment:  getEnv("ENVIRONMENT", "development"),
		DBHost:       getEnv("DB_HOST", "localhost"),
		DBPort:       getEnv("DB_PORT", "5432"),
		DBUser:       getEnv("DB_USER", "postgres"),
		DBPassword:   getEnv("DB_PASSWORD", "postgres"),
		DBName:       getEnv("DB_NAME", "core"),
		JwtKey:       getEnv("JWT_SECRET", "super-secret-key"),
		MailHost:     os.Getenv("MAIL_HOST"),
		MailPort:     cast.ToInt(os.Getenv("MAIL_PORT")),
		MailUsername: os.Getenv("MAIL_USERNAME"),
		MailPassword: os.Getenv("MAIL_PASSWORD"),
	}
}

func getEnv(key, defaultValue string) string {
	val := os.Getenv(key)
	if val == "" {
		return defaultValue
	}
	return val
}
 
 
 
============================================= 
ARQUIVO: C:\go-projects\go-jwt-api\db\db.go 
============================================= 
 
// db/db.go
package db

import (
	"fmt"
	"log"

	"go-jwt-api/config"
	"go-jwt-api/models"

	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

var DB *gorm.DB

func InitDBConfig() {
	c := config.AppConfig

	dsn := fmt.Sprintf(
		"host=%s user=%s password=%s dbname=%s port=%s sslmode=disable",
		c.DBHost, c.DBUser, c.DBPassword, c.DBName, c.DBPort,
	)

	var err error
	DB, err = gorm.Open(postgres.Open(dsn), &gorm.Config{})
	if err != nil {
		log.Fatal("Failed to connect to database:", err)
	}

	err = DB.AutoMigrate(&models.User{})
	if err != nil {
		log.Fatal("Failed to auto-migrate database:", err)
	}
}
 
 
 
============================================= 
ARQUIVO: C:\go-projects\go-jwt-api\exceptions\auth.go 
============================================= 
 
// exceptions/auth.go
package exceptions

import (
	"errors"
	"go-jwt-api/services"
	"go-jwt-api/utils"
	"net/http"

	"github.com/gin-gonic/gin"
)

type ErrorResponse struct {
	Error   string            `json:"error"`
	Details map[string]string `json:"details,omitempty"`
}

type ErrorMapping struct {
	StatusCode int
	Message    string
}

var authErrorMap = map[error]ErrorMapping{
	services.ErrUsernameExists: {
		StatusCode: http.StatusBadRequest,
		Message:    "Username already exists",
	},
	services.ErrEmailExists: {
		StatusCode: http.StatusBadRequest,
		Message:    "Email already exists",
	},
	services.ErrUserNotFound: {
		StatusCode: http.StatusUnauthorized,
		Message:    "User not found",
	},
	services.ErrIncorrectPassword: {
		StatusCode: http.StatusUnauthorized,
		Message:    "Incorrect password",
	},
	services.ErrInvalidToken: {
		StatusCode: http.StatusUnauthorized,
		Message:    "Invalid token",
	},
	services.ErrInvalidTokenType: {
		StatusCode: http.StatusUnauthorized,
		Message:    "Invalid token type",
	},
	services.ErrHashPassword: {
		StatusCode: http.StatusInternalServerError,
		Message:    "Could not hash password",
	},
	services.ErrCreateUser: {
		StatusCode: http.StatusInternalServerError,
		Message:    "Failed to create user",
	},
	services.ErrGenerateTokens: {
		StatusCode: http.StatusInternalServerError,
		Message:    "Could not generate tokens",
	},
	services.ErrDatabaseError: {
		StatusCode: http.StatusInternalServerError,
		Message:    "Database error",
	},
}

func AuthError(c *gin.Context, err error) {
	for serviceErr, mapping := range authErrorMap {
		if errors.Is(err, serviceErr) {
			utils.SendJSONError(c, mapping.StatusCode, ErrorResponse{Error: mapping.Message}, []string{})
			return
		}
	}
	utils.SendJSONError(c, http.StatusInternalServerError, ErrorResponse{Error: "Internal server error"}, []string{})
}

func AuthErrorWithCustomStatus(c *gin.Context, err error, customMappings map[error]ErrorMapping) {
	for serviceErr, mapping := range customMappings {
		if errors.Is(err, serviceErr) {
			utils.SendJSONError(c, mapping.StatusCode, ErrorResponse{Error: mapping.Message}, []string{})
			return
		}
	}
	AuthError(c, err)
}

func Error(c *gin.Context, statusCode int, message string) {
	utils.SendJSONError(c, statusCode, ErrorResponse{Error: message}, []string{})
}

func ValidationError(c *gin.Context, validationErrors interface{}) {
	utils.SendJSON(c, http.StatusBadRequest, gin.H{"validation_errors": validationErrors}, []string{})
}
 
 
 
============================================= 
ARQUIVO: C:\go-projects\go-jwt-api\handlers\auth.go 
============================================= 
 
// handlers/auth.go
package handlers

import (
	"fmt"
	"go-jwt-api/exceptions"
	"go-jwt-api/services"
	"go-jwt-api/utils"
	"go-jwt-api/validators"
	"net/http"

	"github.com/gin-gonic/gin"
)

func SignUp(c *gin.Context) {
	var req validators.SignUpRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		exceptions.Error(c, http.StatusBadRequest, "Invalid signup request")
		return
	}

	if validationErrors := validators.ValidateStruct(req); validationErrors != nil {
		exceptions.ValidationError(c, validationErrors)
		return
	}

	if err := services.RegisterUser(req); err != nil {
		exceptions.AuthError(c, err)
		return
	}

	utils.SendJSON(c, http.StatusCreated, gin.H{"message": "User registered successfully"}, []string{})
}

func SignIn(c *gin.Context) {
	var req validators.SignInRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		exceptions.Error(c, http.StatusBadRequest, "Invalid signin request")
		return
	}

	if validationErrors := validators.ValidateStruct(req); validationErrors != nil {
		exceptions.ValidationError(c, validationErrors)
		return
	}

	accessToken, refreshToken, accessExpiration, refreshExpiration, err := services.AuthenticateUser(req.Username, req.Password)
	if err != nil {
		exceptions.AuthError(c, err)
		return
	}

	services.SetTokenCookies(c, accessToken, refreshToken, accessExpiration, refreshExpiration)
	utils.SendJSON(c, http.StatusOK, gin.H{"message": "Sign in successful"}, []string{})
}

func Refresh(c *gin.Context) {
	refreshTokenStr, err := c.Cookie("session.xrefresh")
	if err != nil {
		exceptions.Error(c, http.StatusBadRequest, "Refresh token not provided")
		return
	}

	accessToken, refreshToken, accessExpiration, refreshExpiration, err := services.RefreshPair(refreshTokenStr)
	if err != nil {
		services.ClearTokenCookies(c)
		exceptions.AuthError(c, err)
		return
	}

	services.SetTokenCookies(c, accessToken, refreshToken, accessExpiration, refreshExpiration)
	utils.SendJSON(c, http.StatusOK, gin.H{"message": "Refreshed successfully"}, []string{})
}

func Me(c *gin.Context) {
	id, exists := c.Get("sub")
	if !exists {
		exceptions.Error(c, http.StatusInternalServerError, "User not found in context")
		return
	}

	user, err := services.FindUserById(id.(uint))
	if err != nil {
		customMappings := map[error]exceptions.ErrorMapping{
			services.ErrUserNotFound: {
				StatusCode: http.StatusNotFound,
				Message:    "User not found",
			},
		}
		exceptions.AuthErrorWithCustomStatus(c, err, customMappings)
		return
	}

	type UserResponse struct {
		Id       uint   `json:"id"`
		Name     string `json:"name"`
		Username string `json:"username"`
		Email    string `json:"email"`
		Main     bool   `json:"main"`
	}

	utils.SendJSON(c, http.StatusOK, gin.H{"user": UserResponse{
		Id:       user.Id,
		Name:     user.Name,
		Username: user.Username,
		Email:    user.Email,
		Main:     user.Main,
	}}, []string{})
}

func UpdateMe(c *gin.Context) {
	var req validators.UpdateMeRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		exceptions.Error(c, http.StatusBadRequest, "Invalid me-edit request")
		return
	}
	if validationErrors := validators.ValidateStruct(req); validationErrors != nil {
		exceptions.ValidationError(c, validationErrors)
		return
	}

	userId, exists := c.Get("sub")
	if !exists {
		exceptions.Error(c, http.StatusInternalServerError, "User Id not found in context")
		return
	}

	updatedUser, err := services.UpdateUser(userId.(uint), req)
	if err != nil {
		customMappings := map[error]exceptions.ErrorMapping{
			services.ErrUserNotFound: {
				StatusCode: http.StatusNotFound,
				Message:    "User not found",
			},
			services.ErrUsernameExists: {
				StatusCode: http.StatusConflict,
				Message:    "Username is already in use by another user",
			},
			services.ErrEmailExists: {
				StatusCode: http.StatusConflict,
				Message:    "Email is already in use by another user",
			},
		}
		exceptions.AuthErrorWithCustomStatus(c, err, customMappings)
		return
	}

	type UserResponse struct {
		Id       uint   `json:"id"`
		Name     string `json:"name"`
		Username string `json:"username"`
		Email    string `json:"email"`
	}

	utils.SendJSON(c, http.StatusOK, gin.H{
		"message": "Profile updated successfully",
		"user": UserResponse{
			Id:       updatedUser.Id,
			Name:     updatedUser.Name,
			Username: updatedUser.Username,
			Email:    updatedUser.Email,
		},
	}, []string{})
}

func SignOut(c *gin.Context) {
	services.ClearTokenCookies(c)
	utils.SendJSON(c, http.StatusOK, gin.H{"message": "Sign out successful"}, []string{})
}

func ForgotPassword(c *gin.Context) {
	var req validators.ForgotPasswordRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		exceptions.Error(c, http.StatusBadRequest, "Invalid forgot-password request")
		return
	}

	if validationErrors := validators.ValidateStruct(req); validationErrors != nil {
		exceptions.ValidationError(c, validationErrors)
		return
	}

	user, err := services.FindUserByEmail(req.Email)
	if err != nil {
		customMappings := map[error]exceptions.ErrorMapping{
			services.ErrUserNotFound: {
				StatusCode: http.StatusNotFound,
				Message:    "User with this email was not found",
			},
		}
		exceptions.AuthErrorWithCustomStatus(c, err, customMappings)
		return
	}

	token, err := services.SetForgotPasswordToken(user)
	if err != nil {
		exceptions.AuthError(c, err)
		return
	}

	if err := services.SendPasswordRecoveryEmail(user, token); err != nil {
		exceptions.Error(c, http.StatusInternalServerError, "Failed to send recovery email")
		return
	}

	utils.SendJSON(c, http.StatusOK, gin.H{
		"message": fmt.Sprintf("Password recovery instructions sent to %s", user.Email),
	}, []string{})
}

func ResetPasswordValidToken(c *gin.Context) {
	token := c.Param("token")
	if token == "" {
		exceptions.Error(c, http.StatusBadRequest, "Token is required")
		return
	}

	isValid, err := services.IsResetPasswordTokenValid(token)
	if err != nil {
		exceptions.AuthError(c, err)
		return
	}

	if !isValid {
		exceptions.Error(c, http.StatusBadRequest, "Invalid or expired token")
		return
	}

	utils.SendJSON(c, http.StatusOK, gin.H{"message": "Token is valid"}, []string{})
}

func ResetPasswordChangePassword(c *gin.Context) {
	token := c.Param("token")
	if token == "" {
		exceptions.Error(c, http.StatusBadRequest, "Token is required")
		return
	}

	isValid, err := services.IsResetPasswordTokenValid(token)
	if err != nil {
		exceptions.AuthError(c, err)
		return
	}

	if !isValid {
		exceptions.Error(c, http.StatusBadRequest, "Invalid or expired token")
		return
	}

	var req validators.ResetPasswordRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		exceptions.Error(c, http.StatusBadRequest, "Invalid reset-password request")
		return
	}

	if validationErrors := validators.ValidateStruct(req); validationErrors != nil {
		exceptions.ValidationError(c, validationErrors)
		return
	}

	if err := services.ChangePasswordWithToken(token, req.NewPassword); err != nil {
		customMappings := map[error]exceptions.ErrorMapping{
			services.ErrInvalidResetToken: {
				StatusCode: http.StatusBadRequest,
				Message:    "Invalid or expired reset token",
			},
		}
		exceptions.AuthErrorWithCustomStatus(c, err, customMappings)
		return
	}

	utils.SendJSON(c, http.StatusOK, gin.H{"message": "Password changed successfully"}, []string{})
}
 
 
 
============================================= 
ARQUIVO: C:\go-projects\go-jwt-api\middlewares\auth.go 
============================================= 
 
// src/middlewares/auth.go
package middlewares

import (
	"go-jwt-api/services"
	"go-jwt-api/utils"
	"net/http"

	"github.com/gin-gonic/gin"
)

func AuthMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		tokenStr, err := c.Cookie("session.xaccess")
		if err != nil || tokenStr == "" {
			utils.SendJSONError(c, http.StatusUnauthorized, gin.H{
				"error": "Access token is required",
			}, []string{})
			c.Abort()
			return
		}

		claims, err := services.ValidateAccessToken(tokenStr)
		if err != nil {
			switch err.Error() {
			case "invalid token":
				utils.SendJSONError(c, http.StatusUnauthorized, gin.H{
					"error": "The provided token is invalid or expired",
				}, []string{})
			case "invalid token type":
				utils.SendJSONError(c, http.StatusUnauthorized, gin.H{
					"error": "Invalid token type provided. Access token is required",
				}, []string{})
			default:
				utils.SendJSONError(c, http.StatusUnauthorized, gin.H{
					"error": "Authentication failed. Please provide a valid access token",
				}, []string{})
			}
			c.Abort()
			return
		}

		c.Set("sub", claims.Id)
		c.Next()
	}
}
 
 
 
============================================= 
ARQUIVO: C:\go-projects\go-jwt-api\models\user.go 
============================================= 
 
// models/user.go
package models

import "time"

type User struct {
	Id                  uint   `gorm:"primaryKey"`
	Name                string `gorm:"not null"`
	Username            string `gorm:"uniqueIndex;not null"`
	Email               string `gorm:"uniqueIndex;not null"`
	Password            string `gorm:"not null"`
	ForgotPasswordToken string `gorm:"default:null"`
	Main                bool   `gorm:"default:true"`
	CreatedAt           time.Time
	UpdatedAt           time.Time
}
 
 
 
============================================= 
ARQUIVO: C:\go-projects\go-jwt-api\routes\auth.go 
============================================= 
 
// routes/auth.go
package routes

import (
	"go-jwt-api/handlers"
	"go-jwt-api/middlewares"

	"github.com/gin-gonic/gin"
)

func RegisterAuthRoutes(r *gin.Engine) {
	authGroup := r.Group("/auth")
	{
		authGroup.POST("/signup", handlers.SignUp)
		authGroup.POST("/signin", handlers.SignIn)
		authGroup.POST("/refresh", handlers.Refresh)
		authGroup.DELETE("/signout", handlers.SignOut)

		authGroup.POST("/forgot-password", handlers.ForgotPassword)
		authGroup.GET("/reset-password/valid-token/:token", handlers.ResetPasswordValidToken)
		authGroup.POST("/reset-password/change-password/:token", handlers.ResetPasswordChangePassword)

		protected := authGroup.Group("/")
		protected.Use(middlewares.AuthMiddleware())
		{
			protected.GET("/me", handlers.Me)
			protected.PUT("/me", handlers.UpdateMe)
		}
	}
}
 
 
 
============================================= 
ARQUIVO: C:\go-projects\go-jwt-api\routes\router.go 
============================================= 
 
// routes/router.go
package routes

import (
	"github.com/gin-gonic/gin"
)

func SetupRoutes(r *gin.Engine) {
	RegisterAuthRoutes(r)
}
 
 
 
============================================= 
ARQUIVO: C:\go-projects\go-jwt-api\services\auth.go 
============================================= 
 
// services/auth.go
package services

import (
	"crypto/rand"
	"encoding/hex"
	"errors"
	"fmt"
	"go-jwt-api/config"
	"go-jwt-api/db"
	"go-jwt-api/models"
	"go-jwt-api/utils"
	"go-jwt-api/validators"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v5"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)

var (
	JwtKey         []byte
	CookieSecure   bool
	CookieDomain   string
	CookieSameSite http.SameSite
)

var (
	ErrUsernameExists    = errors.New("username already exists")
	ErrEmailExists       = errors.New("email already exists")
	ErrUserNotFound      = errors.New("user not found")
	ErrDatabaseError     = errors.New("database error")
	ErrHashPassword      = errors.New("could not hash password")
	ErrCreateUser        = errors.New("failed to create user")
	ErrIncorrectPassword = errors.New("incorrect password")
	ErrGenerateTokens    = errors.New("could not generate tokens")
	ErrInvalidToken      = errors.New("invalid token")
	ErrInvalidTokenType  = errors.New("invalid token type")
	ErrInvalidResetToken = errors.New("invalid or expired reset token")
)

type Claims struct {
	Id        uint   `json:"id"`
	TokenType string `json:"token_type"`
	jwt.RegisteredClaims
}

func InitAuthConfig() {
	JwtKey = []byte(config.AppConfig.JwtKey)

	if config.AppConfig.Environment == "production" {
		CookieSecure = true
		CookieDomain = "https://your-domain.com"
		CookieSameSite = http.SameSiteStrictMode
	} else {
		CookieSecure = false
		CookieDomain = ""
		CookieSameSite = http.SameSiteLaxMode
	}
}

func SetTokenCookies(c *gin.Context, accessToken, refreshToken string, accessExpiration, refreshExpiration time.Time) {
	c.SetCookie("session.xaccess", accessToken, int(time.Until(accessExpiration).Seconds()), "/", CookieDomain, CookieSecure, true)
	c.SetCookie("session.xrefresh", refreshToken, int(time.Until(refreshExpiration).Seconds()), "/", CookieDomain, CookieSecure, true)
	c.SetCookie("session.xstatus", "user_authenticated", int(time.Until(accessExpiration).Seconds()), "/", CookieDomain, CookieSecure, false)
}

func ClearTokenCookies(c *gin.Context) {
	c.SetCookie("session.xaccess", "", -1, "/", CookieDomain, CookieSecure, true)
	c.SetCookie("session.xrefresh", "", -1, "/", CookieDomain, CookieSecure, true)
	c.SetCookie("session.xstatus", "", -1, "/", CookieDomain, CookieSecure, false)
}

func FindUserById(id uint) (*models.User, error) {
	var user models.User
	err := db.DB.Where("id = ?", id).First(&user).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrUserNotFound
		}
		return nil, fmt.Errorf("%w: %v", ErrDatabaseError, err)
	}
	return &user, nil
}

func findUserByUsername(username string) (*models.User, error) {
	var user models.User
	err := db.DB.Where("username = ?", username).First(&user).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrUserNotFound
		}
		return nil, fmt.Errorf("%w: %v", ErrDatabaseError, err)
	}
	return &user, nil
}

func FindUserByEmail(email string) (*models.User, error) {
	var user models.User
	err := db.DB.Where("email = ?", email).First(&user).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrUserNotFound
		}
		return nil, fmt.Errorf("%w: %v", ErrDatabaseError, err)
	}
	return &user, nil
}

func findUserByForgotPasswordToken(token string) (*models.User, error) {
	var user models.User
	err := db.DB.Where("forgot_password_token = ?", token).First(&user).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, ErrUserNotFound
		}
		return nil, fmt.Errorf("%w: %v", ErrDatabaseError, err)
	}
	return &user, nil
}

func createUser(req validators.SignUpRequest) error {
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		return fmt.Errorf("%w: %v", ErrHashPassword, err)
	}

	user := models.User{
		Name:     req.Name,
		Username: req.Username,
		Email:    req.Email,
		Password: string(hashedPassword),
		Main:     true,
	}

	if err := db.DB.Create(&user).Error; err != nil {
		return fmt.Errorf("%w: %v", ErrCreateUser, err)
	}

	return nil
}

func RegisterUser(req validators.SignUpRequest) error {
	_, err := findUserByUsername(req.Username)
	if err != nil && !errors.Is(err, ErrUserNotFound) {
		return err
	}
	if err == nil {
		return ErrUsernameExists
	}

	_, err = FindUserByEmail(req.Email)
	if err != nil && !errors.Is(err, ErrUserNotFound) {
		return err
	}
	if err == nil {
		return ErrEmailExists
	}

	return createUser(req)
}

func UpdateUser(userId uint, req validators.UpdateMeRequest) (*models.User, error) {
	user, err := FindUserById(userId)
	if err != nil {
		return nil, err
	}

	if req.Username != user.Username {
		_, err := findUserByUsername(req.Username)
		if err != nil && !errors.Is(err, ErrUserNotFound) {
			return nil, err
		}
		if err == nil {
			return nil, ErrUsernameExists
		}
	}

	if req.Email != user.Email {
		_, err := FindUserByEmail(req.Email)
		if err != nil && !errors.Is(err, ErrUserNotFound) {
			return nil, err
		}
		if err == nil {
			return nil, ErrEmailExists
		}
	}

	user.Name = req.Name
	user.Username = req.Username
	user.Email = req.Email

	if req.NewPassword != nil && *req.NewPassword != "" {
		hashedPassword, err := bcrypt.GenerateFromPassword([]byte(*req.NewPassword), bcrypt.DefaultCost)
		if err != nil {
			return nil, fmt.Errorf("%w: %v", ErrHashPassword, err)
		}
		user.Password = string(hashedPassword)
	}

	if err := db.DB.Save(user).Error; err != nil {
		return nil, fmt.Errorf("%w: %v", ErrDatabaseError, err)
	}

	return user, nil
}

func AuthenticateUser(username, password string) (accessToken, refreshToken string, accessExpiration, refreshExpiration time.Time, err error) {
	user, err := findUserByUsername(username)
	if err != nil {
		return "", "", time.Time{}, time.Time{}, err
	}

	if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil {
		return "", "", time.Time{}, time.Time{}, ErrIncorrectPassword
	}

	accessToken, refreshToken, _, accessExpiration, refreshExpiration, err = generateTokenPair(user.Id)
	if err != nil {
		return "", "", time.Time{}, time.Time{}, fmt.Errorf("%w: %v", ErrGenerateTokens, err)
	}

	return accessToken, refreshToken, accessExpiration, refreshExpiration, nil
}

func RefreshPair(refreshTokenStr string) (accessToken, refreshToken string, accessExpiration, refreshExpiration time.Time, err error) {
	claims := &Claims{}
	token, err := jwt.ParseWithClaims(refreshTokenStr, claims, func(token *jwt.Token) (interface{}, error) {
		return JwtKey, nil
	})

	if err != nil || !token.Valid {
		return "", "", time.Time{}, time.Time{}, fmt.Errorf("%w: %v", ErrInvalidToken, err)
	}

	if claims.TokenType != "xrefresh" {
		return "", "", time.Time{}, time.Time{}, ErrInvalidTokenType
	}

	user, err := FindUserById(claims.Id)
	if err != nil {
		return "", "", time.Time{}, time.Time{}, err
	}

	accessToken, refreshToken, _, accessExpiration, refreshExpiration, err = generateTokenPair(user.Id)
	if err != nil {
		return "", "", time.Time{}, time.Time{}, fmt.Errorf("%w: %v", ErrGenerateTokens, err)
	}

	return accessToken, refreshToken, accessExpiration, refreshExpiration, nil
}

func ValidateAccessToken(tokenStr string) (*Claims, error) {
	claims := &Claims{}
	token, err := jwt.ParseWithClaims(tokenStr, claims, func(token *jwt.Token) (interface{}, error) {
		return JwtKey, nil
	})

	if err != nil || !token.Valid {
		return nil, fmt.Errorf("%w: %v", ErrInvalidToken, err)
	}

	if claims.TokenType != "xaccess" {
		return nil, ErrInvalidTokenType
	}

	return claims, nil
}

func generateTokenPair(id uint) (accessToken, refreshToken string, expiresIn int64, accessExpiration, refreshExpiration time.Time, err error) {
	now := time.Now()

	accessExpiration = now.Add(15 * time.Minute)
	accessClaims := &Claims{
		Id:        id,
		TokenType: "xaccess",
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(accessExpiration),
			IssuedAt:  jwt.NewNumericDate(now),
		},
	}

	accessTokenObj := jwt.NewWithClaims(jwt.SigningMethodHS256, accessClaims)
	accessToken, err = accessTokenObj.SignedString(JwtKey)
	if err != nil {
		return "", "", 0, time.Time{}, time.Time{}, err
	}

	refreshExpiration = now.Add(7 * 24 * time.Hour)
	refreshClaims := &Claims{
		Id:        id,
		TokenType: "xrefresh",
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(refreshExpiration),
			IssuedAt:  jwt.NewNumericDate(now),
		},
	}

	refreshTokenObj := jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims)
	refreshToken, err = refreshTokenObj.SignedString(JwtKey)
	if err != nil {
		return "", "", 0, time.Time{}, time.Time{}, err
	}

	expiresIn = int64(accessExpiration.Sub(now).Seconds())
	return accessToken, refreshToken, expiresIn, accessExpiration, refreshExpiration, nil
}

func generateForgotPasswordToken() (string, error) {
	bytes := make([]byte, 32)
	if _, err := rand.Read(bytes); err != nil {
		return "", err
	}
	return hex.EncodeToString(bytes), nil
}

func SetForgotPasswordToken(user *models.User) (string, error) {
	token, err := generateForgotPasswordToken()
	if err != nil {
		return "", fmt.Errorf("%w: %v", ErrGenerateTokens, err)
	}

	user.ForgotPasswordToken = token
	if err := db.DB.Save(user).Error; err != nil {
		return "", fmt.Errorf("%w: %v", ErrDatabaseError, err)
	}

	return token, nil
}

func SendPasswordRecoveryEmail(user *models.User, token string) error {
	link := fmt.Sprintf("http://localhost:%s/reset-password/%s", config.AppConfig.PortWeb, token)
	body := fmt.Sprintf(`
		<div style="font-family: Arial, sans-serif; color: #333;">
			<h2 style="color: #2c3e50;">Password Recovery</h2>
			<p>Hello,</p>
			<p>Please click the button below to reset your password:</p>
			<a href="%s" style="
			display: inline-block;
			padding: 10px 20px;
			margin: 15px 0;
			background-color: #005B73;
			color: white;
			text-decoration: none;
			border-radius: 5px;
			font-weight: bold;
			" 
			onmouseover="this.style.backgroundColor='#007991';" 
			onmouseout="this.style.backgroundColor='#005B73';"
			>Reset Password</a>
			<p>If you didn't request a password reset, please ignore this email.</p>
			<p>Thanks,<br/>Your Company Team</p>
		</div>
	`, link)

	if err := utils.SendEmail(user.Email, "Password Recovery", body); err != nil {
		return fmt.Errorf("failed to send recovery email: %w", err)
	}

	return nil
}

func IsResetPasswordTokenValid(token string) (bool, error) {
	_, err := findUserByForgotPasswordToken(token)
	if err != nil {
		if errors.Is(err, ErrUserNotFound) {
			return false, nil
		}
		return false, fmt.Errorf("%w: %v", ErrDatabaseError, err)
	}

	return true, nil
}

func ChangePasswordWithToken(token, newPassword string) error {
	user, err := findUserByForgotPasswordToken(token)
	if err != nil {
		if errors.Is(err, ErrUserNotFound) {
			return ErrInvalidResetToken
		}
		return fmt.Errorf("%w: %v", ErrDatabaseError, err)
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
	if err != nil {
		return fmt.Errorf("%w: %v", ErrHashPassword, err)
	}

	user.Password = string(hashedPassword)
	user.ForgotPasswordToken = ""

	if err := db.DB.Save(user).Error; err != nil {
		return fmt.Errorf("%w: %v", ErrDatabaseError, err)
	}

	return nil
}
 
 
 
============================================= 
ARQUIVO: C:\go-projects\go-jwt-api\tools\docgen.go 
============================================= 
 
package main

import (
	"fmt"
	"os"
	"strings"

	"gopkg.in/yaml.v3"
)

type Request struct {
	URL    string `yaml:"url"`
	Name   string `yaml:"name"`
	Method string `yaml:"method"`
	Body   struct {
		MimeType string `yaml:"mimeType"`
		Text     string `yaml:"text"`
	} `yaml:"body"`
}

type Group struct {
	Name     string    `yaml:"name"`
	Children []Request `yaml:"children"`
}

type Collection struct {
	Collection []Group `yaml:"collection"`
}

func main() {
	data, err := os.ReadFile("go-jwt-api.yaml")
	if err != nil {
		panic(err)
	}

	var parsed Collection
	err = yaml.Unmarshal(data, &parsed)
	if err != nil {
		panic(err)
	}

	html := `
<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>go-jwt-api Documentation</title>
  <style>
	body {
		font-family: 'Segoe UI', sans-serif;
		background-color: #f8f9fa;
		margin: 0;
		padding: 2rem;
		color: #212529;
	}

	h1 {
		font-size: 2.8rem;
		text-align: center;
		margin-bottom: 2.5rem;
		color: #007bff;
		border-bottom: 2px solid #dee2e6;
		padding-bottom: 0.5rem;
	}

	.group {
		border: 1px solid #dee2e6;
		border-radius: 6px;
		margin-bottom: 1rem;
		background: white;
		box-shadow: 0 2px 4px rgba(0,0,0,0.05);
	}

	.group-header {
		padding: 1rem;
		font-size: 1.2rem;
		font-weight: bold;
		background-color: #e9ecef;
		cursor: pointer;
		user-select: none;
		transition: background-color 0.2s;
	}

	.group-header:hover {
		background-color: #d6d8db;
	}

	.group-content {
		display: none;
		padding: 1rem;
	}

	.endpoint {
		margin-bottom: 1.5rem;
		padding: 1rem;
		background: #fefefe;
		border: 1px solid #ccc;
		border-radius: 6px;
	}

	.method {
		font-weight: bold;
		display: inline-block;
		padding: 0.25rem 0.5rem;
		border-radius: 4px;
		margin-right: 0.5rem;
		text-transform: uppercase;
	}

	.GET { background-color: #e2f0d9; color: #2e7d32; }
	.POST { background-color: #d1ecf1; color: #0c5460; }
	.PUT { background-color: #fff3cd; color: #856404; }
	.DELETE { background-color: #f8d7da; color: #721c24; }

	pre {
		background-color: #f1f3f5;
		padding: 1rem;
		border-radius: 6px;
		overflow-x: auto;
		white-space: pre-wrap;
	}
	</style>
</head>
<body>
<h1>go-jwt-api Documentation</h1>
`
	html += `<script>
function toggleGroup(el) {
  const content = el.nextElementSibling;
  if (content.style.display === 'block') {
    content.style.display = 'none';
  } else {
    content.style.display = 'block';
  }
}
</script>`

	for _, group := range parsed.Collection {
		html += `<div class="group">`
		html += fmt.Sprintf(`<div class="group-header" onclick="toggleGroup(this)">%s</div>`, group.Name)
		html += `<div class="group-content">`
		for _, req := range group.Children {
			methodClass := strings.ToUpper(req.Method)
			html += `<div class="endpoint">`
			html += fmt.Sprintf(`<h3><span class="method %s">%s</span> %s</h3>`, methodClass, req.Method, req.URL)
			html += fmt.Sprintf("<p><strong>Nome:</strong> %s</p>", req.Name)
			if req.Body.Text != "" {
				html += "<p><strong>Body:</strong></p><pre>" + req.Body.Text + "</pre>"
			}
			html += "</div>"
		}
		html += `</div></div>`
	}

	html += "</body></html>"

	err = os.WriteFile("docs.html", []byte(html), 0644)
	if err != nil {
		panic(err)
	}

	fmt.Println("📄 Documentação interativa gerada: docs.html")
}
 
 
 
============================================= 
ARQUIVO: C:\go-projects\go-jwt-api\utils\mailer.go 
============================================= 
 
// utils/mailer.go
package utils

import (
	"go-jwt-api/config"
	"log"

	"gopkg.in/gomail.v2"
)

func SendEmail(to string, subject string, body string) error {
	m := gomail.NewMessage()
	m.SetHeader("From", "no-reply@example.com")
	m.SetHeader("To", to)
	m.SetHeader("Subject", subject)
	m.SetBody("text/html", body)

	d := gomail.NewDialer(
		config.AppConfig.MailHost,
		config.AppConfig.MailPort,
		config.AppConfig.MailUsername,
		config.AppConfig.MailPassword,
	)

	if err := d.DialAndSend(m); err != nil {
		log.Println("Email sending failed:", err)
		return err
	}

	log.Println("Email sent to:", to)
	return nil
}
 
 
 
============================================= 
ARQUIVO: C:\go-projects\go-jwt-api\utils\responser.go 
============================================= 
 
// utils/responser.go
package utils

import (
	"encoding/json"
	"time"

	"github.com/gin-gonic/gin"
)

type Meta struct {
	Timestamp string `json:"timestamp"`
}

type ContentResponse struct {
	Message          string                 `json:"message,omitempty"`
	Error            string                 `json:"error,omitempty"`
	ValidationErrors map[string]string      `json:"validation_errors,omitempty"`
	User             interface{}            `json:"user,omitempty"`
	Data             interface{}            `json:"data"`
	Extra            map[string]interface{} `json:"-"`
}

type Response struct {
	Content ContentResponse `json:"content"`
	Meta    Meta            `json:"meta"`
}

func SendJSON(c *gin.Context, status int, content interface{}, data interface{}) {
	contentStruct := buildContentResponse(content, data)
	c.JSON(status, Response{
		Content: contentStruct,
		Meta:    Meta{Timestamp: time.Now().Format(time.RFC3339)},
	})
}

func SendJSONError(c *gin.Context, status int, content interface{}, data interface{}) {
	contentStruct := buildContentResponse(content, data)
	c.JSON(status, Response{
		Content: contentStruct,
		Meta:    Meta{Timestamp: time.Now().Format(time.RFC3339)},
	})
}

func buildContentResponse(content interface{}, data interface{}) ContentResponse {
	result := ContentResponse{Data: data, Extra: make(map[string]interface{})}

	switch v := content.(type) {
	case gin.H:
		for key, value := range v {
			switch key {
			case "message":
				if msg, ok := value.(string); ok {
					result.Message = msg
				}
			case "error":
				if err, ok := value.(string); ok {
					result.Error = err
				}
			case "validation_errors":
				if validationErrs, ok := value.(map[string]string); ok {
					result.ValidationErrors = validationErrs
				}
			case "user":
				result.User = value
			default:
				result.Extra[key] = value
			}
		}
	default:
		contentMap := toMap(v)
		for key, value := range contentMap {
			switch key {
			case "message":
				if msg, ok := value.(string); ok {
					result.Message = msg
				}
			case "error":
				if err, ok := value.(string); ok {
					result.Error = err
				}
			case "validation_errors":
				if validationErrs, ok := value.(map[string]string); ok {
					result.ValidationErrors = validationErrs
				}
			case "user":
				result.User = value
			default:
				result.Extra[key] = value
			}
		}
	}

	return result
}

func toMap(content interface{}) map[string]interface{} {
	switch v := content.(type) {
	case gin.H:
		return v
	default:
		var result map[string]interface{}
		bytes, _ := json.Marshal(v)
		_ = json.Unmarshal(bytes, &result)
		return result
	}
}
 
 
 
============================================= 
ARQUIVO: C:\go-projects\go-jwt-api\validators\auth.go 
============================================= 
 
// validators/auth.go
package validators

type SignUpRequest struct {
	Name     string `json:"name" validate:"required,min=3,max=50"`
	Username string `json:"username" validate:"required,min=3,max=20"`
	Email    string `json:"email" validate:"required,email"`
	Password string `json:"password" validate:"required,min=6,max=30"`
}

type SignInRequest struct {
	Username string `json:"username" validate:"required,min=3,max=20"`
	Password string `json:"password" validate:"required,min=6,max=30"`
}

type ForgotPasswordRequest struct {
	Email string `json:"email" validate:"required,email"`
}

type ResetPasswordRequest struct {
	NewPassword        string `json:"new_password" validate:"required,min=6,max=30"`
	ConfirmNewPassword string `json:"confirm_new_password" validate:"required,eqfield=NewPassword"`
}

type UpdateMeRequest struct {
	Name        string  `json:"name" validate:"required,min=3,max=50"`
	Username    string  `json:"username" validate:"required,min=3,max=20"`
	Email       string  `json:"email" validate:"required,email"`
	NewPassword *string `json:"new_password,omitempty" validate:"omitempty,min=6,max=30"`
}
 
 
 
============================================= 
ARQUIVO: C:\go-projects\go-jwt-api\validators\validator.go 
============================================= 
 
// validators/validator.go
package validators

import (
	"reflect"
	"strings"

	"github.com/go-playground/validator/v10"
)

var validate *validator.Validate

func init() {
	validate = validator.New()
}

func ValidateStruct(data interface{}) map[string]string {
	err := validate.Struct(data)
	if err == nil {
		return nil
	}

	errors := make(map[string]string)
	for _, err := range err.(validator.ValidationErrors) {
		jsonFieldName := getJSONFieldName(data, err.Field())
		errors[err.Field()] = generateErrorMessage(err, jsonFieldName)
	}
	return errors
}

func getJSONFieldName(structInstance interface{}, fieldName string) string {
	structType := reflect.TypeOf(structInstance)

	if structType.Kind() == reflect.Ptr {
		structType = structType.Elem()
	}

	field, found := structType.FieldByName(fieldName)
	if !found {
		return strings.ToLower(fieldName)
	}

	jsonTag := field.Tag.Get("json")
	if jsonTag == "" {
		return strings.ToLower(fieldName)
	}

	jsonName := strings.Split(jsonTag, ",")[0]
	if jsonName == "" || jsonName == "-" {
		return strings.ToLower(fieldName)
	}

	return jsonName
}

func generateErrorMessage(fe validator.FieldError, jsonFieldName string) string {
	switch fe.Tag() {
	case "required":
		return "Field '" + jsonFieldName + "' is required"
	case "min":
		return "Field '" + jsonFieldName + "' must be at least " + fe.Param() + " characters"
	case "max":
		return "Field '" + jsonFieldName + "' must be at most " + fe.Param() + " characters"
	case "len":
		return "Field '" + jsonFieldName + "' must be exactly " + fe.Param() + " characters"
	case "eq":
		return "Field '" + jsonFieldName + "' must be equal to " + fe.Param()
	case "eqfield":
		if jsonFieldName == "confirm_new_password" {
			return "Passwords do not match"
		}
		return "Field '" + jsonFieldName + "' must be equal to field '" + strings.ToLower(fe.Param()) + "'"
	case "ne":
		return "Field '" + jsonFieldName + "' must not be equal to " + fe.Param()
	case "gte":
		return "Field '" + jsonFieldName + "' must be greater than or equal to " + fe.Param()
	case "gt":
		return "Field '" + jsonFieldName + "' must be greater than " + fe.Param()
	case "lte":
		return "Field '" + jsonFieldName + "' must be less than or equal to " + fe.Param()
	case "lt":
		return "Field '" + jsonFieldName + "' must be less than " + fe.Param()
	case "email":
		return "Field '" + jsonFieldName + "' must be a valid email address"
	case "url":
		return "Field '" + jsonFieldName + "' must be a valid URL"
	case "uuid":
		return "Field '" + jsonFieldName + "' must be a valid UUID"
	case "numeric":
		return "Field '" + jsonFieldName + "' must be a numeric value"
	case "alpha":
		return "Field '" + jsonFieldName + "' must contain only letters"
	case "alphanum":
		return "Field '" + jsonFieldName + "' must contain only letters and numbers"
	case "oneof":
		return "Field '" + jsonFieldName + "' must be one of: " + fe.Param()
	case "contains":
		return "Field '" + jsonFieldName + "' must contain " + fe.Param()
	case "startswith":
		return "Field '" + jsonFieldName + "' must start with " + fe.Param()
	case "endswith":
		return "Field '" + jsonFieldName + "' must end with " + fe.Param()
	default:
		return "Field '" + jsonFieldName + "' is invalid"
	}
}
 
 
